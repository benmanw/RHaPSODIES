#version 430

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0) uniform isampler2D texCameraDepth;
layout (binding = 1) uniform isampler2D texRenderedDepth;

layout (binding = 0, r32ui) uniform writeonly restrict uimage2D imgResultDifference;
layout (binding = 1, rg8ui) uniform writeonly restrict uimage2D imgResultUnion;
layout (binding = 2, rg8ui) uniform writeonly restrict uimage2D imgResultIntersection;

uvec4 debug_color(int val);

void main() {
	ivec2 posGlobal = ivec2(gl_GlobalInvocationID.xy);
	vec2  posScreen = vec2(posGlobal) / vec2(320*8, 240*8);

	// why do we have to mask the single bit here? it seems internal
	// format is always signed, but the values should be positive
	// still...	
	ivec4 renderedSample = texture(texRenderedDepth, posScreen);
	ivec4 cameraSample   = texture(texCameraDepth,   posScreen);

	uvec4 diff_value = uvec4(abs(cameraSample-renderedSample)) << 7;
	imageStore(imgResultDifference, posGlobal, diff_value);
	
	// rendered|iCameraSample yield unsigned 24 bit value, where
	// 0x00ffffff is zfar/invalid depth. we fill the first byte, then
	// invert and | for union
	// uint value = 
	// 	~(uRenderedSample[0] | 0xff000000) |
	// 	~(uCameraSample[0]   | 0xff000000);

		
		// ~(0x00fffff1 | 0xff000000) |
		// ~(0x00ffffff | 0xff000000);

	// @todo get rid of branching?
	uvec4 color_set = uvec4(0xff, 0xff, 0, 0xff);
	uvec4 color_unset = uvec4(0,    0, 0, 0xff);
	uvec4 color_out;

	// union
	uint value = ((renderedSample | cameraSample) & 0x007fffff)[0];
	if(value)
		color_out = color_set;
	else
		color_out = color_unset;

//	color_out = debug_color(renderedSample.x);

	imageStore(imgResultUnion, posGlobal, color_out);

	// intersection
	bool intersect =
		((renderedSample[0] & 0x007fffff) > 0) &&
		((cameraSample[0]   & 0x007fffff) > 0);
	if(intersect)
		color_out = color_set;
	else
		color_out = color_unset;

	imageStore(imgResultIntersection, posGlobal, color_out);
	
}

uvec4 debug_color(int val) {
	uvec4 color_out;
	
	if(gl_GlobalInvocationID[0] / 500 == 0) {
		color_out = uvec4(0,
						  (val & 0xff000000) >> 24,
						  0,
						  0);
	}
	if(gl_GlobalInvocationID[0] / 500 == 1) {
		color_out = uvec4(0,
						  (val & 0x00ff0000) >> 16,
						  0,
						  0);
	}
	if(gl_GlobalInvocationID[0] / 500 == 2) {
		color_out = uvec4(0,
						  (val & 0x0000ff00) >> 8,
						  0,
						  0);
	}
	if(gl_GlobalInvocationID[0] / 500 == 3) {
		color_out = uvec4(0,
						  (val & 0x000000ff) >> 0,
						  0,
						  0);
	}
	return color_out;
}
